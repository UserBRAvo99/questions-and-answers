const dataJS = [
  {
    question: "Типи даних в в JavaScript?",
    answer:
      "numbers, string, booleans, objects, undefined, null, (BigInt, Symbol - from developer mozilla)",
  },
  {
    question: "Що таке NaN?",
    answer:
      "NaN - Not a Number - спеціальне значення в JavaScript, яка вказує що вираз або операція яку виконали не є числом. Може виникнути у різних ситуаціях. Наприклад, віднімання нечислового значення від числа, ділення нуля на нуль, або спроба взяти квадратний корінь з від'ємного числа.  Щоб перевірити, чи змінна містить NaN, можна використовувати функцію isNaN()",
  },
  {
    question: "В чому різниця між null та undefined?",
    answer:
      "null - вказує на відсутність значення або об'єкта (наприклад якщо в prompt() нічого не ввести і натиснути ОК - значення змінної буде null ). undefined - вказує на відсутність значення, тобто ніщо. Якщо оголисити змінну , але не вказати їй жодного, то ми отримуємо undefined, також функції можуть повернути undefined",
  },
  {
    question: "Чим відрізняється строга рівність від не строгої (=== і ==)?",
    answer:
      "=== - оператор строгої рівності, тобто все дорівнює собі. Перед оцінкою нічого не перетворюється. == - нестрога рівність, виконують претворення типів порівнювальних значень(тому якщо порівняти число 1 з рядком 1 або null == undefined, отримаємо true , що може призвести до помилки при обробки значень в деяких випадках)",
  },
  {
    question: "Логічні оператори !, &&, ||. Як працюють? ",
    answer:
      "! - оператор NOT - це унарний оператор, який виконує операцію над одним операндом з правої сторони. && - AND - приводить всі операнди до буля і повертає значення одного з них. Лівий операнд - якщо його можна привести до false, і правий - в інших випадках. || - OR - приводить всі операнди до буля і повертає значення одного з них. Лівий операнд - якщо його можна привести до true, і правий - в інших випадках.",
  },
  {
    question: "Що таке use strict і для чого він потрібен?",
    answer:
      "use strict - строгий режим, запообігає створенню змінних в глобальному режимі(змінні з однаковою назвою не конфліктують в різних файлах), забороняє використовувати this в глобальному контексті(інакше він буде звертатися до window). Краще завжди писати код в строгому режимі.",
  },
  {
    question: "Чому результатом порівняння двох схожих обєктів буде false?",
    answer:
      "Тому що , хоч вони можуть бути і ідентичними, та вони мають різні посилання на адресу пам'яті. Тому вони не можуть бути рівними",
  },
  {
    question: "Як перевірити ідентичність 2х обєктів?",
    answer:
      "Можна скористатись JSON.stringify() і зробити глибоке порівняння, та треба пам'ятати, що цей підхід має свої обмеження, і він не враховує всі аспекти об'єктів, такі як функції або спеціальні властивості, які не серіалізуються до JSON. Можна перебрати ключ і значення в циклі за допомогою Object.entries(obj). Також можна скористатися бібліотекою  Lodash isEqual() наприклад _.isEqual(obj1, obj2)",
  },
  {
    question: "Як зробити копію обєкта?",
    answer:
      "Можна створити копію за допомогою оператора spread (тобто розпилити старий об'єкт в новий, це створить незалежну копію),або за допомогою Object.assign({}, початковийОб'єкт) і JSON.parse(JSON.stringify(початковийОб'єкт))",
  },
  {
    question: "Чим відрізняються змінні var, let и const?",
    answer:
      "var, let и const - основні способи оголошення змінної. var - має функціональну область видимості, піддаються подняттю (hoisting), можуть бути повторно оголошені в одному і тому ж блоку коду. let - мають блочну область видимості (block scope),піддаються подняттю, можна отримати доступ до них до їхнього оголошення. const - мають блочну область видимості, значення не можна переназначити після першого присвоєння, не піддаються подняттю. Краще використовувати let або const, вони надають більший контроль над змінними.",
  },
  {
    question: "Як дізнатись, чи являються дані масивом?",
    answer: "Array.isArray() - вбудована функція, яка повертає true або false.",
  },
  {
    question: "Які перебираючі методи масивів ви знаєте?",
    answer:
      ".map((element, index, array) => {}). students.flatMap(arr => arr.key) - схожий на map, але застосовується коли треба розгладити багатовимірний масив. .filter((element, index, array) => {}), .find((element, index, array) => {}), .findIndex((element, index, array) => {}), every(), some(), reduce((previousValue, element, index, array) => {}, initialValue), деструктуризуючі методи(бажано робити копію масиву, для того щоб не змінити оригінал, це хороша практика) - sort(),",
  },
  {
    question: "Як обєднати масиви?",
    answer: "Це можна зробити за допомогою concat() або spreаd оператора",
  },
  {
    question: "Як дізнатись, чи знаходиться елемент в масиві?",
    answer:
      "Це можна зробити за допомогою includes() і some() - повернуть boolean, find() - повернуть значення або перебрати масив в циклі і порівняти значення на кожній ітерації",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
  {
    question: "",
    answer: "",
  },
];
export default dataJS;
