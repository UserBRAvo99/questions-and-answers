{"version":3,"file":"static/js/843.ac2cb153.chunk.js","mappings":"kMAuKA,EAvKiB,CACf,CACEA,SACE,0TACFC,OACE,wtJAEJ,CACED,SAAU,kJACVC,OACE,qsGAEJ,CACED,SAAU,qQACVC,OACE,40DAEJ,CACED,SACE,+WACFC,OACE,gmDAEJ,CACED,SAAU,gSACVC,OACE,g3EAEJ,CACED,SAAU,mKACVC,OACE,23GAEJ,CACED,SACE,8TACFC,OACE,onDAEJ,CACED,SACE,qXACFC,OACE,q2FAEJ,CACED,SAAU,qOACVC,OACE,2uJAEJ,CACED,SAAU,gGACVC,OACE,q+CAEJ,CACED,SAAU,sDACVC,OACE,6kEAEJ,CACED,SAAU,gMACVC,OACE,0oGAEJ,CACED,SAAU,6RACVC,OACE,mgEAEJ,CACED,SAAU,uHACVC,OACE,2gCAEJ,CACED,SAAU,qGACVC,OACE,q+EAEJ,CACED,SAAU,gQACVC,OACE,s8LAEJ,CACED,SAAU,gIACVC,OACE,uyCAEJ,CACED,SAAU,6GACVC,OACE,g4CAEJ,CACED,SACE,mXACFC,OACE,2mGAEJ,CACED,SAAU,uIACVC,OACE,80BAEJ,CACED,SAAU,+DACVC,OACE,+3DAEJ,CACED,SAAU,gQACVC,OACE,siDAEJ,CACED,SAAU,oKACVC,OACE,onCAEJ,CACED,SAAU,6KACVC,OACE,2iCAEJ,CACED,SAAU,4LACVC,OACE,4dAEJ,CACED,SAAU,6FACVC,OACE,snBAEJ,CACED,SAAU,8RACVC,OACE,u7CAEJ,CACED,SACE,4YACFC,OACE,qyDAEJ,CACED,SACE,kNACFC,OACE,gyBAEJ,CACED,SAAU,kKACVC,OAAQ,IAEV,CACED,SAAU,GACVC,OAAQ,IAEV,CACED,SAAU,GACVC,OAAQ,K,oCChJZ,MAfA,SAA8BC,GAC5B,OACEC,EAAAA,EAAAA,KAACC,EAAI,CAAAC,SACFH,EAAKI,KAAI,SAAAC,GAA2B,IAAxBP,EAAQO,EAARP,SAAUC,EAAMM,EAANN,OACrB,OACEO,EAAAA,EAAAA,MAACC,EAAI,CAAAJ,SAAA,EACHF,EAAAA,EAAAA,KAACO,EAAK,CAAAL,SAAEL,KACRG,EAAAA,EAAAA,KAACQ,EAAS,CAAAN,SAAEJ,OAFHW,EAAAA,EAAAA,MAKf,KAGN,EAIMR,EAAOS,EAAAA,GAAOC,GAAEC,IAAAA,GAAAC,EAAAA,EAAAA,GAAA,uDAKhBP,EAAOI,EAAAA,GAAOI,GAAEC,IAAAA,GAAAF,EAAAA,EAAAA,GAAA,QAEhBN,EAAQG,EAAAA,GAAOM,GAAEC,IAAAA,GAAAJ,EAAAA,EAAAA,GAAA,QAEjBL,EAAYE,EAAAA,GAAOQ,EAACC,IAAAA,GAAAN,EAAAA,EAAAA,GAAA,QCvB1B,MAJA,WACE,OAAOO,EAAqBC,EAC9B,ECEA,MAJA,WACE,OAAOrB,EAAAA,EAAAA,KAACsB,EAAa,GACvB,C","sources":["Data/dataHTML.js","utilities/questionAnswerRender.jsx","Components/ComponentHTML.jsx","Pages/HTMLInfo.jsx"],"sourcesContent":["const dataHTML = [\r\n  {\r\n    question:\r\n      \"Що таке DOCTYPE і для чого він потрібен? Що буде, якщо його не вказати?\",\r\n    answer:\r\n      \"DOCTYPE <!DOCTYPE> - повинен бути першим елементом в html-документі, йде перед тегом <html>. В першу чергу це декларація, а не тег. Тобто інструкція для веб-браузера про те, як інтерпритувати поточну HTML сторінку. Оскільки HTML існує в декількох версіях, крім того, є XHTML (EXtensible HyperText Markup Language, розширена мова розмітки гіпертексту), схожа на HTML, але розрізняється з ним по синтаксису. І щоб браузер правильно інтерпретував вашу сторінку необхідно завжди вказувати, тому що в старіших версіях HTML може перейти в режим сумісності, де він намагатиметься інтерпретувати HTML на основі певних стандартів, які можуть варіюватися залежно від браузера та його версії. Це може призвести до непередбачуваного відображення вашого веб-документа, оскільки різні браузери можуть інтерпретувати код по-різному.. Та якщо не вказати <!DOCTYPE> в HTML5 то браузер все одно буде інтерпретувати документ, в такому випадку, браузер буде використовувати стандартні правила та режим відображеня для HTML5. Але бажано завжди вказувати <!DOCTYPE>. \",\r\n  },\r\n  {\r\n    question: \"Для чого потрібні мета-теги?\",\r\n    answer:\r\n      \"Мета-теги використовуються для зберігання інформації, призначеної для браузера і пошукових систем: встановлення кодування елемента, передача інформації пошуковим системам і багато іншого. Мета тегів може бути кілька, тому що , залежно від використання атрибутів, вони несуть різну інформацію. Необхідно вказувати кодування сторінки для того, щоб браузер коректно відобразив текст. Якщо цього не зробити, або задати не вірне кодування, замість символів браузер може відобразити ієрогліфи - <meta charset=utf-8 /> - найпоширеніше кодування. Короткий опис змісту допомагає пошуковим системам краще проіндексувати сторінку - <meta name='description' content='Вивчення основ HTML5'/>. \",\r\n  },\r\n  {\r\n    question: \"Чим відрізняється блочний елемент від строчного?\",\r\n    answer:\r\n      \"Блоковий елемент (block-level element) - займає повністю весь рядок, незалежно від обсягу його контенту, тому кілька блокових елементів візуально йдуть один за одним. Рядковий елемент (inline element) - займає місце по своєму вмісту, тому кілька малих елементів можуть розташуватися на одному рядку. Якщо в рядку не вистачає місця для вміщення рядкового елемента, він переносить на новий рядок.\",\r\n  },\r\n  {\r\n    question:\r\n      \"Чому деякі символи можуть відображатись на сторінці у виді квадратів?\",\r\n    answer:\r\n      \"Зазвичай це вказує на проблему з кодуванням символів або використанням непідтримуваних символів. Наприклад неправильне кодування символів, помилка UTF-8. Чи несумісність зі шрифтом. Також можливе використання спеціальних символів, такі як  <, >, &,  і їх треба екранувати за допомогою сутностей HTML  (наприклад, &lt;, &gt;, &amp; відповідно).\",\r\n  },\r\n  {\r\n    question: \"Що таке семантична верстка? Які семантичні теги знаєте?\",\r\n    answer:\r\n      \"Семантична розмітка - підхід до створення HTML-розмітки ґрунтується на використанні тегів за їх призначенням відповідно до специфікації і які відповідають типу контенту, що розмічується.Тобто семантична розмітка означає, що теги не вибираються на підставі того, як вони відображаються в браузері - вони вибираються на підставі типу та структури контенту, який розмічується. Наприклад - <h1> <header> <nav> <main> <img> <p> <a><footer> . Також симантичні теги допомагають при читанні сторінок. Ще приклад: <figure> <figcaption> \",\r\n  },\r\n  {\r\n    question: \"Які типи заголовків існують в HTML?\",\r\n    answer:\r\n      \"Заголовки в  HTML - це група тегів <h1> <h2> <h3> <h4> <h5> <h6> - визначає текстові золовки смислових розділів різного рівня, які вказують на важливість секції контенту, розташованого після них. Це інструмент структурування текстового контенту. Тег <h1> прийнято використовувати одни раз на сторінці, як основний заголовок. Решта заголовків можуть використовуватися скільки завгодно разів, та головне дотримуватись ієрархії. Пошукові системи звертають особливу увагу на заголовки, тому коректне використання цієї групи тегів вкрай важливе. Не визначайте рівень заголовка за розміром тексту на макеті. Не весь великий текст - заголовки. Заголовок - це те, що за змістом озаглавлює секцію контенту.\",\r\n  },\r\n  {\r\n    question:\r\n      \"Що називається потоком документа в HTML? Чи можна його змінювати?\",\r\n    answer:\r\n      \"Потік - це вертикальний і горизонтальний порядок послідовного відображення елементів на сторінці. Вертикально потік йде зверху вниз, і , за замовчуванням, елементи відображаються на сторінці в тому порядку, в якому вони вказані в HTML-документі. Горизонтально потік йде зліва направо. Потік можна змінювати за допомогою CSS і JS\",\r\n  },\r\n  {\r\n    question:\r\n      \"Які існують способи підключення JavaScript до html-сторінки? В чому між ними різниця?\",\r\n    answer:\r\n      \"Існує декілька способів підключення JavaScript. Перший варіант - створюємо файл з розширенням js і поміщаємо його у підпапку js(не обв'язково, та є хорошою практикою), потім вказуємо шлях скрипту в атрибуті src тега script. Підключати треба в кінці тега body після всього контенту. Це важливо, для того щоб спочатку відрендеревся контент та розмітка, а потім почав працювати скрипт. Другий варіан - JavaScript можна підключити в head, та треба пам'ятати що спочатку інтерпритатор прочитає скрипт і тільки потім перейде до розмітки. Можна застосувати async , та для зручності бажано використовувати перший варіант \",\r\n  },\r\n  {\r\n    question: \"Які існують способи додавання CSS на сторінку?\",\r\n    answer:\r\n      \"CSS (Cascading Style Sheets, каскадні таблиці стилів) - це мова для опису і зміни зовнішнього вигляду елементів. HTML використовується для визначення структури і семантики документу, а CSS - для його оформлення і позиціонування, Стилі можна підключити: вбудовані стилі (inline styles), вбудована таблиця стилів (embedded stylesheet), зовнішня таблиця стилів(external stylesheet). Вбудовані стилі - задаються тегу безпосередньо в атрибут style - їх складно перевизначити або використати повторно, застосовуються в рідких випадках - <p style='color:blue; font-size:24px;'>Цей текст буде синім.</p>. Вбудована таблиця стилів -  CSS-правила додаються всередину тегу <style> в шапці документа. Їх неможливо використовувати повторно на інших сторінках і складно масштабувати і підтримувати. Зовнішня таблиця стилів - Зовнішній CSS-код легко масштабувати, підтримувати і використовувати повторно на інших сторінках, тому це стандарт підключення стилів. У проекті створюється окремий файл стилів з розширенням .css і підключається в HTML-документі. Підключається CSS-код в head <link rel='stylesheet' href='./css/styles.css' />\",\r\n  },\r\n  {\r\n    question: \"Різниця між reset.css и normalize.css?\",\r\n    answer:\r\n      \"Використовувати можна обидва варіанти. reset.css - cкидує стилі елементів, тобто накладаю однорідний стиль для всіх елементів. normalize.css - зберігає корисні стилі браузерів по замовчуванню(тобто узгоджує вигляд між різними браузерами), також може виправляти деякі баги на мобільних та десктопних присторях. \",\r\n  },\r\n  {\r\n    question: \"Що таке critical CSS?\",\r\n    answer:\r\n      \"Це техніка оптимізації завантаження сторінки. Суть такого підходу полягає в тому, що стилі які потребуються для першого рендерінгу, таким чином зменшується час завантаження частини сторінки. Це може бути важливо для першого враження користувача. При такому підході можна користуватись інлайновими стилями(стилі прописуюься одразу в тегові) та вбудованої таблиці стилів(стилі прописуються в head в тегові style type='text/css')\",\r\n  },\r\n  {\r\n    question: \"Що таке специфічність селекторів в CSS?\",\r\n    answer:\r\n      \"Специфічність - це спосіб, за допомогою якого браузери визначають, які CSS-властивості найбільше відповідають елементу і як наслідок, будуть застосовані. Тобто якщо є два або більше суперечливих(конфліктуючих) правил CSS, що вказують на один і той самий елемент, браузер слідує деяким правилам. Кожен селектор має своє місце в ієрархії специфічності. Вбудовані стилі мають найбільшу специфічність, ID поступають вбудованим , але переважають інші. На третьому місці будуть класи, атрибути та псевдокласи.Селектор класу переважає будь-яку кількість селекторів елементів. При рівній специфічності - враховується останнє правило. \",\r\n  },\r\n  {\r\n    question: \"В чому різниця між псевдокласом та всевдоелементом в CSS?\",\r\n    answer:\r\n      \"Псевдокласи використовуються для вибору елементів у певному стані або з певними характеристиками, такими як перший, останній, наведений, активний тощо. Псевдоелементи використовуються для стилізації певних частин елементів, які не є окремими HTML-елементами. можна використати для для створення стилів для першого абзацу внутрішнього тексту або вставки вмісту перед або після певного елемента\",\r\n  },\r\n  {\r\n    question: \"Що таке блочна модель CSS?\",\r\n    answer:\r\n      \"Блочна модель - це блочний елемент, прямокутний контейнер, незалежно від того, як він візувльно представлений на сторінці. В елемента є область вмісту і необов'язкові поля, відступи та межі(рамка). Content, padding, border, margin.\",\r\n  },\r\n  {\r\n    question: \"Яку роль виконує box-sizing?\",\r\n    answer:\r\n      \"Визнає як браузер обчислює обсяг елемента, включаючи його ширину та висоту, а також відступи та границі. Два основних значення: content-box - величина елемента обчислюється на основі висоти контенту в межах границі, розміри падінгів та гнраниць додаються до вказаної ширини та висоти елемента. border-box - величина елемента обчислюється на основі вмісту та включає падінги і границі. Тобто розміри падінгів і границь врахвуються в межах вказаної ширини та висоти елемента. Найчастіше використовується box-sizing: border-box\",\r\n  },\r\n  {\r\n    question: \"Які є види позиціонування елементів на сторінці?\",\r\n    answer:\r\n      \"Relative Positioning (Відносне позиціонування): При відносному позиціонуванні, елемент зсувається відносно свого звичайного місця в потоці документа, але залишає відображення простору для нього на своєму оригінальному місці. Це дозволяє використовувати властивості top, right, bottom і left для зміщення елемента відносно його звичайного положення.Absolute Positioning (Абсолютне позиціонування): При абсолютному позиціонуванні, елемент вилучається з потоку документа, і його позиція визначається відносно батьківського елемента, якщо батьківський елемент також має встановлене позиціонування, або відносно вікна перегляду.Fixed Positioning (Фіксоване позиціонування): Елемент з фіксованим позиціонуванням розташовується відносно вікна перегляду і не змінює своє положення при прокручуванні сторінки. Sticky Positioning (Липке позиціонування): Липке позиціонування комбінує властивості відносного і фіксованого позиціонування. Елемент спочатку розташовується відносно вікна, але при прокручуванні сторінки він прилипає до батьківського контейнера або певного позначеного місця.Static Positioning (Статичне позиціонування): Це значення за замовчуванням для позиціонування елементів. Елементи розміщуються в звичайному порядку потоку документа.\",\r\n  },\r\n  {\r\n    question: \"Що робить властивість z-index?\",\r\n    answer:\r\n      \"Позиційовані елементи випадають із потоку і для них приміняється z-index, який визначає(контролює) глибину позиціонованих елементів на сторінці по осі z - від очей корристувача і до екрану(перепендикулярно до площини екрану). Має позитивні і негативні значення\",\r\n  },\r\n  {\r\n    question: \"В чому різниця між px, em, rem?\",\r\n    answer:\r\n      \"Одиниці вимірювання(розміру) шрифтів в CSS. PX - абсолютна одиниця вимірювання EM - відносна одиниця вимірювання, яка залежить відносно шрифту батьківського елемента. REM - відносна одиниця вимірювання відносно шрифту кореневого елементу(сприяє більш адаптивному розміру шрифта).\",\r\n  },\r\n  {\r\n    question:\r\n      \"Що таке гумова, адаптивна та відзивчива верстка? В чому між ними різниця?\",\r\n    answer:\r\n      \"Гумова верстка - це підхід до веб розробки, при якому веб-сайт створюється з виорнистанням відсоткових значень для визначення ширини елементів і сторінки щоб адаптуватися до різних розмірів екранів. Адаптивна верстка - має кілька точок перерізу(breakpoints - медіа запити), на яких змінюється структура і вигляд сторінки, щоб оптимально відображати на різних присторях. Відзивчива(респонсивна) верстка - більш сучасний і складніший підхід , який використовуе медіа запити та інші техніки (комбінація гумової і адаптивної) для адаптації сайту до різних пристроїв і розмірів екрану. (рекомендований підхід на сьогоднішній день)\",\r\n  },\r\n  {\r\n    question: \"В чому різниця між visibility:hidden и display:none?\",\r\n    answer:\r\n      \"visibility:hidden - приховує елемент, але залишає його в потоці та простір на сторінці, табто елемент не буде видимий для користувачаю. display:none - приховує елемент та забирає його з потоку\",\r\n  },\r\n  {\r\n    question: \"Що таке repaint и reflow?\",\r\n    answer:\r\n      \"repaint(перемальовує) - процес відбуваеться коли елемент на сторінці змінює свій вигляд без змін розмітки або розташування. Структура сторінки не змінюється, змінитися може колір, відступи або інші стилі елементів. reflow (перераховує) - процес відбувається при зміні розміру,положення або структури елемента наторінці(видалення або додавання, зміна розташування або невидимість).\",\r\n  },\r\n  {\r\n    question: \"Яка різниця між відносною та абсолютною адресою?\",\r\n    answer:\r\n      \"Абсолютна адреса - це повна адреса, яка вказує точно на конкретний об'єкт або місцезнаходження без врахування контексту, тобто включає всю інформацію необхідну для знаходження ресурсу в мережі - https://www.example.com/images/pic.jpg . Відносна адреса - вказує на об'єкт або місце знаходження відносно поточного контексту або об'єкту - ..//images/pic.jpg \",\r\n  },\r\n  {\r\n    question: \"Різниця між тегом та елементом?\",\r\n    answer:\r\n      \"Різниця в тому що тег - це маркер у синтаксисі розмітки  <p>, <div>, <a>, <img>, <br> . А елемент це відкриваючий і закриваючий тег(або не парний тег), також враховуються атрибути та інформація яка міститься всередені(вкладенисть елементів,текст)\",\r\n  },\r\n  {\r\n    question: \"Коли ви використовуєте <button> , а коли <a>?\",\r\n    answer:\r\n      \"<button> - використовується для відправки форм, взаємодією з кормтувачем при натисканні(js) або ж динамічних змін. <a> - зазвичай використовується для гіперпосилань, переходу на інші сторінки, навігації по веб-сторінці\",\r\n  },\r\n  {\r\n    question: \"Для чого потрібен атрибут type у кнопки?\",\r\n    answer:\r\n      \"Якщо це стосується кнопки, то type - визначає тип дії яку виконує кнопка(submit, reset, button), за замовчуванням type=button. \",\r\n  },\r\n  {\r\n    question: \"Різниця між checkbox та radio?\",\r\n    answer:\r\n      \"checkbox та radio - це типи input. checkbox - надає можливість обрати декілька варіантів відповіді, а з radio - можна вибрати лише один варіант з декількох.\",\r\n  },\r\n  {\r\n    question: \"Що таке наслідування стилів в CSS? І що таке каскадність в CSS?\",\r\n    answer:\r\n      \"Наслідування стилів - це передача певних стилів від батьківського елементу до дочірнього. Каскадність - описує спосіб вирішення конфлікту між різними стилями, які застосовуються до одного елемента. Які саме стилі будуть в приоритеті, можна розрахувати за допомогою специфічності \",\r\n  },\r\n  {\r\n    question:\r\n      \"В чому різниця між контентними і оформлюючими/декоративними зображеннями?\",\r\n    answer:\r\n      \"Контентні зображення допомагать донести повідомлення сторінки до користувача( це можуть бути фотографії, ілюстрації, графіки, тощо), повинні мати атрибут alt - з коротким описом зображення(для скрін рідерів). Оформлюючі/декоративні зображення - не впливають на контент сторінки і несуть переважно функцію полібшення дизайну(фон, риски, декоративні ефекти)\",\r\n  },\r\n  {\r\n    question:\r\n      \"Чому у <img> та <input> не  має псевдоелементіов ::before, ::after?\",\r\n    answer:\r\n      \"<img> та <input> - не мають вмісту, тобто не містять внутрішніх елементів тексту або коду, які можна було б модифікувати або задати стилі за допомогою псевдоелементів\",\r\n  },\r\n  {\r\n    question: \"Що таке flex-контейнер та flex-елемент?\",\r\n    answer: \"\",\r\n  },\r\n  {\r\n    question: \"\",\r\n    answer: \"\",\r\n  },\r\n  {\r\n    question: \"\",\r\n    answer: \"\",\r\n  },\r\n];\r\n\r\nexport default dataHTML;\r\n","import { nanoid } from \"nanoid\";\r\nimport React from \"react\";\r\nimport { styled } from \"styled-components\";\r\n\r\nfunction questionAnswerRender(data) {\r\n  return (\r\n    <List>\r\n      {data.map(({ question, answer }) => {\r\n        return (\r\n          <Item key={nanoid()}>\r\n            <Title>{question}</Title>\r\n            <Paragraph>{answer}</Paragraph>\r\n          </Item>\r\n        );\r\n      })}\r\n    </List>\r\n  );\r\n}\r\n\r\nexport default questionAnswerRender;\r\n\r\nconst List = styled.ul`\r\n  display: flex;\r\n  flex-direction: column;\r\n`;\r\n\r\nconst Item = styled.li``;\r\n\r\nconst Title = styled.h2``;\r\n\r\nconst Paragraph = styled.p``;\r\n","import dataHTML from \"../Data/dataHTML\";\r\nimport questionAnswerRender from \"../utilities/questionAnswerRender\";\r\n\r\nfunction ComponentHTML() {\r\n  return questionAnswerRender(dataHTML);\r\n}\r\n\r\nexport default ComponentHTML;\r\n","import React from \"react\";\r\nimport ComponentHTML from \"../Components/ComponentHTML\";\r\n\r\nfunction HTMLInfo() {\r\n  return <ComponentHTML />;\r\n}\r\n\r\nexport default HTMLInfo;\r\n"],"names":["question","answer","data","_jsx","List","children","map","_ref","_jsxs","Item","Title","Paragraph","nanoid","styled","ul","_templateObject","_taggedTemplateLiteral","li","_templateObject2","h2","_templateObject3","p","_templateObject4","questionAnswerRender","dataHTML","ComponentHTML"],"sourceRoot":""}